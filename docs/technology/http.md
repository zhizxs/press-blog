---
title: http基础
date: 2019-10-18
categories:
  - FrontEnd

tags:
  - http/https
  - 缓存

isShowComments: true
---

:::tip

1. http/https 协议
2. tcp 协议
3. 握手与挥手
   :::

<!-- more -->

## 为什么利用多个域名来存储网站资源会更有效？

- CDN 缓存更方便
- 突破浏览器并发限制
- 节约 cookie 带宽
- 节约主域名的连接数，优化页面响应速度

## http/https 协议

- 1.0 协议缺陷: + 无法复用链接，完成即断开，重新慢启动和 TCP 3 次握手 + head of line blocking: 线头阻塞，导致请求之间互相影响

- 1.1 改进: + 长连接(默认 keep-alive)，复用 + host 字段指定对应的虚拟站点

      	+ 新增功能:
      		+ 断点续传
      		+ 身份认证
      		+ 状态管理
      		+ cache 缓存
      		+ Cache-Control
      		+ Expires
      		+ Last-Modified
      		+ Etag

- 2.0: + 多路复用 + 二进制分帧层: 应用层和传输层之间 + 首部压缩 + 服务端推送

## http 请求报文

- 请求行 - 包含请求方法、uri 和协议的版本，用空格分隔，例如：GET/sample.jsp HTTP/1.1

- 请求头部 - 包含有关客户端环境及请求正文的信息，如请求正文长度、浏览器所用编码格式等

- 请求数据 - 即客户端发送给服务器的内容，可为空（GET 请求就没有请求数据），例如：username=jinqiao&password=1234

> - 请求头部和请求数据之间必须有空行，用以区分。
> - 最常用的请求头部是 Content-Type（请求编码方式）和 Content-Length（请求数据长度）

```
Content-Type: application/x-www-form-urlencoded
Content-Length: 35
```

## http 应答报文

- 状态行：协议版本、状态码、简要描述，例如：HTTP/1.1 200 OK
- 响应头部：必须指明 Content-Type，其他可选，例如：Content-Type: text/plain
- 响应数据：即服务器回应客户端的内容

**常见状态码**

- 1xx：指示信息--表示请求已接收，继续处理。
- 2xx：成功--表示请求已被成功接收、理解、接受。
- 3xx：重定向--要完成请求必须进行更进一步的操作。
- 4xx：客户端错误--请求有语法错误或请求无法实现。
- 5xx：服务器端错误--服务器未能实现合法的请求。

## TCP/IP 协议

> TCP/IP 协议模型（Transmission Control Protocol/Internet Protocol）包含了一系列构成互联网基础的网络协议通过 20 多年的发展已日渐成熟，并被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。TCP/IP 协议簇是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统，与 OSI 的七层模型相对应。

**HTTP 协议就是基于 TCP/IP 协议模型来传输信息的。**

- 链路层
  也称作数据链路层或网络接口层（网络接口层和硬件层），通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。物理层
- 网络层
  互联网层（网际层），处理分组在网络中的活动，例如分组的选路。在 TCP/IP 协议族中，网络层协议包括 IP 协议（网际协议），ICMP 协议（Internet 互联网控制报文协议），以及 IGMP 协议（Internet 组管理协议）。
  P 是一种网络层协议，提供的是一种不可靠的服务
- 传输层
  主要为两台主机上的应用程序提供端到端的通信。在 TCP/IP 协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和 UDP（用户数据报协议）。
  TCP 为两台主机提供高可靠性的数据通信。
- 应用层
  应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。包括 HTTP，FTP（File Transfer Protocol，文件传输协议），DNS（Domain Name System，域名系统）服务。

> **当应用程序用 TCP 传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息）。 当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing）。协议是通过目的端口号、源 I P 地址和源端口号进行解包的**

## 三次握手？为什么？

- 第一次握手 - 建立连接。 - 客户端发送连接请求报文段，将 SYN 位置为 1，Sequence Number 为 x； - 客户端进入 SYN_SEND 状态，等待服务器的确认；
- 第二次握手

      	- 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；
      	- 自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；
      	- 服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；

- 第三次握手 - 客户端收到服务器的 SYN+ACK 报文段。 - 然后将 Acknowledgment Number 设置为 y+1，向服务器发送 ACK 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 ESTABLISHED 状态，完成 TCP 三次握手。

> why?为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

- 具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”

## 为什么断开的时候是四次挥手？

- 第一次分手

  - 主机 1（可以使客户端，也可以是服务器端），设置 Sequence Number，向主机 2 发送一个 FIN 报文段；此时，主机 1 进入 FIN_WAIT_1 状态；这表示主机 1 没有数据要发送给主机 2 了；

- 第二次分手

  - 主机 2 收到了主机 1 发送的 FIN 报文段，向主机 1 回一个 ACK 报文段，Acknowledgment Number 为 Sequence Number 加 1；主机 1 进入 FIN_WAIT_2 状态；
  - 主机 2 告诉主机 1，我“同意”你的关闭请求；

- 第三次分手

  - 主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 LAST_ACK 状态；

- 第四次分手

  - 主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收到主机 1 的 ACK 报文段以后，就关闭连接；
  - 此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了。

- why?

      	TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。
