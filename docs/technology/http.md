# 面试小点

## 为什么利用多个域名来存储网站资源会更有效？
- CDN缓存更方便
- 突破浏览器并发限制
- 节约cookie带宽
- 节约主域名的连接数，优化页面响应速度

## http/https 协议
- 1.0 协议缺陷:
	+ 无法复用链接，完成即断开，重新慢启动和 TCP 3次握手
	+ head of line blocking: 线头阻塞，导致请求之间互相影响

- 1.1 改进:
	+ 长连接(默认 keep-alive)，复用
	+ host 字段指定对应的虚拟站点

	+ 新增功能:
		+ 断点续传
		+ 身份认证
		+ 状态管理
		+ cache 缓存
		+ Cache-Control
		+ Expires
		+ Last-Modified
		+ Etag
- 2.0:
	+ 多路复用
	+ 二进制分帧层: 应用层和传输层之间
	+ 首部压缩
	+ 服务端推送

## http请求报文
+ 请求行
	- 包含请求方法、uri和协议的版本，用空格分隔，例如：GET/sample.jsp HTTP/1.1

+ 请求头部
	- 包含有关客户端环境及请求正文的信息，如请求正文长度、浏览器所用编码格式等

+ 请求数据
	- 即客户端发送给服务器的内容，可为空（GET请求就没有请求数据），例如：username=jinqiao&password=1234

> - 请求头部和请求数据之间必须有空行，用以区分。
> - 最常用的请求头部是Content-Type（请求编码方式）和Content-Length（请求数据长度）

  ```
	Content-Type: application/x-www-form-urlencoded 
	Content-Length: 35 
  ```

## http 应答报文
- 状态行：协议版本、状态码、简要描述，例如：HTTP/1.1 200 OK
- 响应头部：必须指明Content-Type，其他可选，例如：Content-Type: text/plain
- 响应数据：即服务器回应客户端的内容
 
**常见状态码**
- 1xx：指示信息--表示请求已接收，继续处理。
- 2xx：成功--表示请求已被成功接收、理解、接受。
- 3xx：重定向--要完成请求必须进行更进一步的操作。
- 4xx：客户端错误--请求有语法错误或请求无法实现。
- 5xx：服务器端错误--服务器未能实现合法的请求。


## TCP/IP 协议
> TCP/IP协议模型（Transmission Control Protocol/Internet Protocol）包含了一系列构成互联网基础的网络协议通过20多年的发展已日渐成熟，并被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。TCP/IP协议簇是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统，与OSI的七层模型相对应。

**HTTP协议就是基于TCP/IP协议模型来传输信息的。**
- 链路层
	也称作数据链路层或网络接口层（网络接口层和硬件层），通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。物理层
- 网络层
	互联网层（网际层），处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议）。
	P是一种网络层协议，提供的是一种不可靠的服务
- 传输层
	主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。
	TCP为两台主机提供高可靠性的数据通信。
- 应用层
	 应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。包括 HTTP，FTP（File Transfer Protocol，文件传输协议），DNS（Domain Name System，域名系统）服务。

> **当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息）。  当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing）。协议是通过目的端口号、源I P地址和源端口号进行解包的**


## 三次握手？为什么？

- 第一次握手
	- 建立连接。
	- 客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；
	- 客户端进入SYN_SEND状态，等待服务器的确认；
- 第二次握手

	- 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；
	- 自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；
	- 服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
- 第三次握手
	- 客户端收到服务器的SYN+ACK报文段。
	- 然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

>why?为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

- 具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”

## 为什么断开的时候是四次挥手？

- 第一次分手
    - 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；

- 第二次分手

    - 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；
    - 主机2告诉主机1，我“同意”你的关闭请求；

- 第三次分手

    - 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；

- 第四次分手

    - 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；
    - 此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。

- why?

	TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。
